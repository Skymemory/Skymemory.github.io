---
layout:     post
title:      "那些年面过的算法题"
date:       2018-08-26 19:30:00 +0800
author:     "Sky丶Memory"
header-img: "img/2018-08-26-01-bg.webp"
tags: Algorithm 面试
---

#### 一

> 给定n + 1个元素的整型数组，每个元素值域为[1, n]，数组中有一个元素重复，但不知重复了几次，请找出该重复的数字。要求空间复杂度为O(1)，时间复杂度小于O(n^2)，且原数组只读

由于条件限制空间复杂度为***O(1)***、原数组只读，所以排序或下标索引的方法都行不通。仔细观察题目会发现一个有趣的地方：**每个元素值域为[1,n]**，题目既然给定了这个条件，那求解过程中很大可能上会用到它。

元素既然存在重复，那如果按照一个规则将原始集合分为**S1**和**S2**，那相同元素必然在同一个集合中，而另一个集合中元素都不相同。在[1,n]选择一个数m，将原始集合划分为两部分:

- **S1**：小于等于m
- **S2**：大于m

这样，**S1**、**S2**中必然是一个集合中存在重复元素、另一个集合中元素都不同，通过条件`len(S1) + len(S2) = n + 1`是可以判断出哪部分存在重复元素，进而缩小求解范围并继续迭代该过程即可求解。

``` python
def solve(nums):
    low, high = 1, len(nums) - 1
    while low < high:
        mid = (low + high) >> 1
        cnt = len(filter(lambda x: x <= mid, nums))
        if cnt <= mid:
            low = mid + 1
        else:
            high = mid
    return low
```

