---
layout:     post
title:      "Redis复制"
date:       2019-03-02 08:00:00 +0800
author:     "Sky丶Memory"
header-img: "img/2019-03-02-01-bg.jpeg"
tags: Redis Storage


---

最近突然想学习下分布式存储下面的路由和复制功能的设计思路，所以先从复制开始学起。

复制分为两种：同步复制、异步复制，常见使用异步复制有Mysql、Redis，同步复制需要使用类似2PC、3PC、Paxos、Raft等一致性协议来保证。

由于同步复制的坑略深，还是先从异步复制开始

#### Redis复制

首先，需要清楚任何master节点上都有一个Replication ID，简称复制ID，复制ID唯一标识数据集，所以不同master复制ID是不同的。

在复制ID相同的情况下，又增加了一个维度—偏移量（offset）来标识不同实例的数据集是否一致，所以对于主从复制来说，完全可以通过（Replication ID, offset）来进行主从间的数据同步。

Redis的复制支持两种方式：全量同步和增量同步，大体的实现思路可以概括为：

- 全量同步：主实例拉起一个后台进程产生RDB文件，同时记录从该时间点起主实例数据集发生变更的写命令到一个缓冲区，RDB文件dump完成后，主实例发送已生成的RDB文件给从节点，待发送完毕后，再将缓冲区记录的命令发送给客户端
- 增量复制：主实例默认有存放最近一段时间内的写命令到一个缓冲区—复制积压缓冲区，如果从节点和主节点的偏移量差值刚好在复制积压缓冲区中，那么主实例只用发送这部分增量数据即可

在学习这部分过程中，有两个问题个人觉得比较有意思：

- 主、从实例之间确认机制是什么？
- 发生故障转移时，从节点提升为master节点后，之前master节点的从节点复制策略是什么？

##### 确认机制

当主实例执行写命令后，命令传播的流程大体如下：

![](/img/2019-03-02-01-01.png)

需要注意的是，命令从主实例发送后，主实例并不关心从实例命令的执行情况，也就是说，这个确认是异步确认的，那怎么确认的呢？通过心跳检测确认

在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：

 `REPLCONF ACK <replication_offset> `

这样主实例对比offset就能知道命令是否存在丢失而进行补发

##### 故障转移时的复制策略

在2.8～4.0版本之间，故障转移是导致主实例复制ID变化的情况下，从节点进行全量复制

在4.0版本后，进行了这部分的改进，支持增量同步

至于技术实现方案，暂时没看懂，后续看懂了补上

