---
layout:     post
title:      "n + 1个元素，每个元素值域为[1,n]，其中某个元素重复多次，请找出该元素"
date:       2018-08-26 19:30:00 +0800
author:     "Sky丶Memory"
header-img: "img/2018-08-26-01-bg.webp"
tags: Algorithm
---


最近去一家公司面试，面试过程中被问到了一道算法题目，感觉还算是一道有点意思的题目，所以写出来分享下思路.

> 给定n + 1个元素的整型数组，每个元素值域为[1, n]，数组中有一个元素重复，但不知重复了几次，请找出重复的数字。要求空间复杂度为O(1)，时间复杂度小于O(n^2)，且原数组只读

### 解法

由于要求中明确限制了空间复杂度为O(1)且原数组只读，所以用数组下标索引的方法基本行不通。通过仔细观察题目给定的条件，会发现“每个元素的值域为[1,n]”这个条件给的很有疑问，因为如果这个问题解法是泛化的，那么就没必要限定值域，所以值域的范围对问题的求解是必不可少的。

既然值域范围为[1,n]，那随机选择一个数m(1<=m<=n)，将原始数组分成两部分观察下性质。假定我们通过m将原数组分为小于等于m的部分a和大于m的部分b，那重复的数字一定分到其中的一部分，而另一部分中的数字是互斥的，而且我们很容易知道重复的数字存在于哪一部分，也就是我们能得到重复数字的取值区间，既然能得到其取值区间，二分枚举即可

整理下上述思考的思路，不难得出整个算法流程:

1. 初始low = 1, high = n，对应重复数字的可能值域
2. 取[low, high]中点mid，利用mid值将原数组分为两部分，根据重复数字在哪部分更新对应的low、high值
3. 不停重复步骤2，直到找到重复数字

从算法流程上，可以看出该算法的时间复杂度为O(nlgn)，空间复杂度为O(1)，具体实现代码:

``` python
def findRepeatNumber(numbers):
    low, high = 1, len(numbers) - 1
    while low <= high:
        mid = (low + high) / 2
        cnt = len(filter(lambda x: x <= mid, numbers))
        if cnt <= mid:
            low = mid + 1
        else:
            high = mid - 1

    return low
```

