I",<p>最近碰到一个算法题：</p>

<blockquote>
  <p>班级中有n个同学，每个同学有身高~hi~和~wi~，现将这些同学排成一个队，队中相邻同学需满足体重单调递减、身高递增的性质，求队列可能的最长长度。</p>
</blockquote>

<p>递增或递减的性质，容易想到将这些同学以h或w进行相应的排序，这样同学间的相对位置就不再发生变化，唯一变化的是每个位置选与不选的问题。</p>

<p>这里以对体重降序为例，将同学以体重降序排序后，原始问题就转换为<strong>给定n个元素的数字，求最长上升子序列长度</strong>。</p>

<p>对于转换后的问题，<strong><em>O(n^2)</em></strong>的解法是比较直观的，定义<code class="language-plaintext highlighter-rouge">dp[i]</code>表示以位置<code class="language-plaintext highlighter-rouge">i</code>为结束点的最长上升子序列长度，不难得到如下代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>

</code></pre></div></div>

<p><strong><em>O(n^2)</em></strong>的解法往往只是提供了最原始思路，我们需要在此基础上进行算法优化。</p>

<p>仔细思考上述求解过程，会更进一步发现问题的本质：<strong>对于任意位置i，需要找到之前小于nums[i]且最大dp[j]（j&lt;i)</strong>。一般看到最值问题，容易联想到RMQ数据结构。</p>

<p>是的，没错，但要转换为RMQ面临一个问题—小于nums[i]这个条件；稍微熟悉RMQ数据结构的人，或多或少听过一个概念—离散化，把原始数据进行离散化即可解决小于nums[i]这个条件。</p>

<p>因此，我们可以通过离散化+RMQ数据结构，将这个查找过程从<strong><em>O(n)</em></strong>优化到<strong><em>O(lgn)</em></strong><em>，最终我们得到了一个</em><strong>o(nlgn)</strong>的解法。</p>

<p>但上述的这些分析、解法都不是我想写这篇文章的原因，脑子里始终觉得使用RMQ把问题搞得复杂化了，虽然最终我得到了一个<strong><em>o(nlgn)</em></strong>的解法。</p>

<p>我们在回归到上述分析的这句话上：<strong>对于任意位置i，需要找到之前小于nums[i]且最大dp[j]（j&lt;i)</strong>。这句话定义了整个问题的本质，不妨换个角度思考，对于当前位置i，影响当前位置决策的位置有没有可能存在某种性质。</p>

<p>来看一个简单的证明题：</p>

<blockquote>
  <p>假设当前位置为k，k &gt; i，k &gt; j，nums[k] &gt; nums[i]，nums[k] &gt; nums[j]，若有nums[i] &lt;= nums[j]且dp[i] &gt;= dp[j]，则任何时候i比j更优。</p>
</blockquote>

<p>我们可以通过反证法来验证，假设以位置k为结束点的最长上升子序列包含位置j，则将位置j替换为位置i，结果不会比当前值差，结论得证。</p>

<p>上面的结论能更进一步的泛化为：</p>

<blockquote>
  <p>对于任意i、j，若nums[i] &lt;= nums[j]且dp[i] &gt;= dp[j]，则任何时候i比j更优。</p>
</blockquote>

<p>有了这个结论，再来看看对问题的求解有什么帮助。</p>

<p>对于前i个元素，有用元素构成的序列必然满足—<strong>nums[j] &lt; nums[k] 且dp[j] &lt; dp[k]，j &lt;= i, k &lt;= i</strong>，记为<strong>性质1</strong></p>

<p>所以，对于求解问题：<strong>对于任意位置i，需要找到之前小于nums[i]且最大dp[j]（j&lt;i)</strong>，我们只需要维持一个单调队列，队列中元素满足<strong>性质1</strong>，求解位置i时，只需去队列中查找小于nums[i]的最大值并将当前位置信息插入到队列即可。</p>

<p>由于单调队列存在有序性，所以查找、插入都可在<strong><em>O(lgn)</em></strong>时间内完成。</p>

<p>那么问题又来了，这个队列需要支持快速查找、插入，用什么数据结构比较合适呢。</p>

<p>队列中元素以<code class="language-plaintext highlighter-rouge">(nums[i],dp[i])</code>形式保存，插入是个麻烦事，需要保持有序性，那这种数据结构基本上就可以确定为平衡二叉树，平衡二叉树写起来比RMQ数据结构还麻烦，显然与我最初的优化旨意违背，不可取。</p>

<p>这里之所以会选用平衡二叉树，本质在于nums[i]有序性导致插入开销，观察队列中存放的元素<code class="language-plaintext highlighter-rouge">(num[i],dp[i])</code>，等等，<code class="language-plaintext highlighter-rouge">dp[i]</code>不是保存的以i为结束点的最长上升子序列长度吗，很显然其值域为<code class="language-plaintext highlighter-rouge">[1,n]</code>,并且这个<code class="language-plaintext highlighter-rouge">dp[i]</code>必然是从1开始的连续整数。</p>

<p>所以我们采用逆向思路，队列中元素以<code class="language-plaintext highlighter-rouge">(dp[i],nums[i])</code>的形式保存，这样就能将<code class="language-plaintext highlighter-rouge">dp[i]</code>映射为数组下标，直接在数组上利用二分查找就能完美解决我们的问题了：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">bisect</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">pos</span><span class="p">]:</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">bisect</span><span class="p">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hi</span><span class="o">=</span><span class="n">pos</span><span class="p">)]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<p>嗯，你没看错，整个代码不到15行，短小、精简、强悍，你值得拥有。。。（oops，我又调皮了）</p>

<h4 id="一点感想">一点感想</h4>

<p>从获知到这个题目到写完这篇文章，花了我大约一天的时间找到我想要的最优解，个人觉得有两个点比较有意思。</p>

<p>一者，如何发现单调性这个性质，除了经验、大胆的假设，暂时没有想到其他的办法，思维有时候就是这么神奇，只能刻意练习，没有捷径可寻。</p>

<p>二者，当发现需要使用平衡二叉树的时候，自己或多或少还是有些沮丧，停滞不前，这种时候，一定要定义清楚问题的本质，才有可能找到新的思路，这部分的优化应了那句”山重水复疑无路，柳暗花明又一村”。</p>

<p>关于如何定义并分析问题，我觉得知乎上<a href="https://www.zhihu.com/question/304174916">厉害的人是怎么分析问题的</a>排名第一高票回答提出的这个模型还是蛮有意思的，在尝试中。。。</p>

<p>最后，整个优化过程让我萌生了另外一个想法：</p>

<p>假设人的生命终点是60岁，那我们需要用60年时间去度过这个过程，而这60年期间，会经历各种各样的事情，如果以时间线罗列这些事情，你会发现这是个<strong><em>O(n)</em></strong>的时间复杂度；最优解中讲述了怎么把<strong><em>O(n)</em></strong>降为<strong><em>O(lgn)</em></strong>方法，我觉得这个方法同样适合生命的轨迹，人一生会经历很多事情，但这些事情中对我们产生价值或有影响的是有限的，我们应当去发现、探索对自身有意义的事情，并做好对应的沉淀，只有通过这种方式来优化自身的生命轨迹，才能可能节省大量不必要浪费的时间来找寻对自己更有意思的事情。</p>

<p>最后，来一句，纵然是举案齐眉，到底意难平。</p>
:ET